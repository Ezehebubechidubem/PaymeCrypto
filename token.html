<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Token â€” Payme Crypto</title>
  <style>
    body { margin:0; font-family:"Segoe UI",sans-serif; background:linear-gradient(135deg,#0f2027,#203a43,#2c5364); color:#fff; min-height:100vh; display:flex; align-items:center; justify-content:center; padding:20px; }
    .card{ background:rgba(255,255,255,0.05); border-radius:16px; padding:20px; width:100%; max-width:640px; box-shadow:0 6px 20px rgba(0,0,0,0.4);}
    .row { display:flex; gap:12px; align-items:center; }
    .token-img{ width:48px;height:48px;border-radius:50%;object-fit:cover; }
    .muted{ color: rgba(255,255,255,0.75); font-size:13px; }
    .positive{ color:#7CFCB3; font-weight:700; }
    .negative{ color:#ff6b6b; font-weight:700; }
    a.button{ display:inline-block; padding:10px 14px; background:#1e90ff; color:#fff; border-radius:8px; text-decoration:none; margin-top:12px; }
  </style>
</head>
<body>
  <div class="card">
    <div id="header" class="row">
      <img id="logo" class="token-img" src="" alt="logo" />
      <div>
        <div id="title" style="font-size:20px;font-weight:800"></div>
        <div id="subtitle" class="muted"></div>
      </div>
    </div>

    <div style="margin-top:16px">
      <div><strong>Balance:</strong> <span id="bal">-</span></div>
      <div><strong>USD value:</strong> $<span id="usd">-</span></div>
      <div><strong>24h change:</strong> <span id="chg">-</span></div>
      <div style="margin-top:8px"><strong>Contract:</strong> <span id="contract">-</span></div>
      <div><strong>Chain:</strong> <span id="chain">-</span></div>
      <div style="margin-top:8px"><strong>Address (this chain):</strong> <div id="addr" class="muted" style="word-break:break-all"></div></div>
    </div>

    <div style="margin-top:18px">
      <a class="button" href="testing.html">Back</a>
    </div>
  </div>

  <script>
    // backend link (same as dashboard)
    const BACKEND_URL = "https://paymecrypto-1.onrender.com";

    // read selected token saved from dashboard
    const sel = JSON.parse(localStorage.getItem("selected_token") || "null");
    const wallet = JSON.parse(localStorage.getItem("payme_wallet") || "{}"); // keep your stored wallet obj

    async function renderTokenDetails(){
      if(!sel){ document.getElementById("title").innerText = "No token selected"; return; }
      const { key, meta, net } = sel;
      // fast show previously known meta if available
      document.getElementById("logo").src = meta.image || "";
      document.getElementById("title").innerText = `${meta.name || key} (${meta.symbol||key})`;
      document.getElementById("subtitle").innerText = `Network: ${net}`;

      // Display a chain-aware address:
      // if wallet contains addresses mapping (e.g. wallet.addresses.solana), use that for non-EVM chains.
      // fallback to wallet.address (the main EVM address).
      function chainSpecificAddress(chain){
        // token HTML doesn't always know exact chain; infer: if key matches known testnet symbol (PYM) or net==='testnet', use wallet.address
        // If meta provides chain property (not always), use it.
        const tokenChain = (meta && meta.chain) ? meta.chain : (net === 'testnet' ? 'testnet' : 'ethereum');
        const addrs = wallet && wallet.addresses ? wallet.addresses : null;
        if(addrs && addrs[tokenChain]) return addrs[tokenChain];
        // fallback to top-level address
        return wallet && wallet.address ? wallet.address : "No address stored";
      }

      document.getElementById("addr").innerText = chainSpecificAddress(meta.chain || "ethereum");

      // fetch live details from backend
      try {
        // if meta has coinGecko id (we used coin ids as keys for mainnet), call /api/balance with coin_ids
        const payload = {
          chain: (meta.chain && meta.chain !== "ethereum") ? meta.chain : "ethereum",
          address: chainSpecificAddress(meta.chain || "ethereum"),
          coin_ids: []
        };
        // If the key looks like a coinGecko id (has lowercase and not simple symbol), include as coin_id
        // We'll try both: if meta && meta.isPayme => testnet entry; otherwise pass coin id if available
        if(net === "mainnet" && key && key.indexOf(" ") === -1 && key === key.toLowerCase()){
          payload.coin_ids = [key];
        } else if(net === "mainnet" && meta && meta.symbol){
          // still try coin id by symbol lookup via backend search as fallback
          // But to keep code simple, pass empty coin_ids and rely on token entry fallback
          payload.coin_ids = payload.coin_ids || [];
        }

        const res = await fetch(`${BACKEND_URL}/api/balance`, {
          method: "POST",
          headers: {"Content-Type":"application/json"},
          body: JSON.stringify(payload)
        });
        const j = await res.json();

        // determine best token entry from response
        let entry = null;
        if(Array.isArray(j.tokens) && j.tokens.length){
          // find by coin_id matching key OR contract or symbol
          entry = j.tokens.find(t => (t.coin_id === key) || (t.contract && meta && meta.contract && t.contract.toLowerCase() === meta.contract.toLowerCase()) || (t.symbol && t.symbol.toUpperCase() === (meta.symbol||"").toUpperCase()));
          if(!entry) entry = j.tokens[0];
        } else if(j.native && (meta.symbol && j.native.symbol && (j.native.symbol.toUpperCase() === (meta.symbol||"").toUpperCase() || j.native.symbol.toUpperCase().includes((meta.symbol||"").toUpperCase())))){
          entry = { name: j.native.symbol, symbol: j.native.symbol, balance: j.native.balance, usd_price: j.native.usd_price, price_change_24h: j.native.price_change_24h };
        }

        // display result (fall back to the meta we had)
        const bal = entry ? Number(entry.balance || 0) : (meta.balance || 0);
        const usdVal = entry ? (Number(entry.usd_price || meta.price || 0) * bal) : ((meta.price || 0) * bal);
        const pct = entry ? (entry.price_change_24h || meta.pct || 0) : (meta.pct || 0);

        document.getElementById("bal").innerText = (bal > 0 && bal < 0.01) ? "<0.01" : fmtVisible(bal);
        document.getElementById("usd").innerText = (usdVal > 0 && usdVal < 0.01) ? "<0.01" : (usdVal ? fmtVisible(usdVal) : "0.00");
        const chgEl = document.getElementById("chg");
        chgEl.innerText = (pct>=0?"+":"") + (pct||0).toFixed(2) + "%";
        chgEl.className = pct < 0 ? "negative" : "positive";

        document.getElementById("contract").innerText = (entry && entry.contract) ? entry.contract : (meta.contract || "Native");
        document.getElementById("chain").innerText = (entry && entry.chain) ? (entry.chain || "ethereum") : (meta.chain || "ethereum");

      } catch(e){
        console.warn("token details fetch failed", e);
        // show local meta fallback
        document.getElementById("bal").innerText = fmtVisible(meta.balance || 0);
        document.getElementById("usd").innerText = meta.price ? fmtVisible((meta.price||0) * (meta.balance||0)) : "0.00";
        const pct = meta.pct || 0;
        const chgEl = document.getElementById("chg");
        chgEl.innerText = (pct>=0?"+":"") + (pct||0).toFixed(2) + "%";
        chgEl.className = pct < 0 ? "negative" : "positive";
        document.getElementById("contract").innerText = meta.contract || "Native";
        document.getElementById("chain").innerText = meta.chain || "ethereum";
      }
    }

    function fmtVisible(n){
      try {
        if(Math.abs(Number(n)) < 0.01 && Number(n) !== 0) return "<0.01";
        return Number(n).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:8});
      } catch { return String(n); }
    }

    renderTokenDetails();
  </script>
</body>
</html>