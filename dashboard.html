<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Payme Crypto — Dashboard</title>

  <!-- ethers v6 UMD -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.6.0/dist/ethers.umd.min.js"></script>

  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      background: linear-gradient(135deg,#0f2027,#203a43,#2c5364);
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 { margin: 10px 0 20px; font-size: 26px; color: #00ffae; }
    .card {
      background: rgba(255,255,255,0.05);
      border-radius: 16px;
      padding: 20px;
      width: 100%;
      max-width: 500px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      margin-bottom: 20px;
    }
    .wallet-info { text-align: center; margin-bottom: 15px; }
    .wallet-address {
      font-family: monospace;
      background: rgba(0,0,0,0.3);
      padding: 8px;
      border-radius: 10px;
      word-break: break-all;
      margin: 8px 0;
    }
    .network-toggle { display: flex; justify-content: center; gap: 12px; margin: 10px 0; }
    .network-toggle button {
      padding: 8px 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      background: #1b3a4b;
      color: #fff;
    }
    .network-toggle .active { background: #00ffae; color: #00221a; }
    .balance { font-size: 24px; font-weight: bold; margin: 15px 0; color: #00ffae; }

    /* ACTIONS: always horizontal (desktop & mobile) */
    .actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin: 15px 0;
      flex-direction: row; /* horizontal */
      /* allow horizontal scrolling on very narrow screens while keeping horizontal layout */
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 2px;
    }
    .actions button {
      flex: 1;           /* equal width across row */
      min-width: 80px;  /* ensures they remain usable on small screens */
      padding: 12px 16px;
      font-size: 16px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      white-space: nowrap;
    }
    .send { background: #ff6b6b; color: #fff; }
    .receive { background: #32cd32; color: #fff; }
    .buy { background: #1e90ff; color: #fff; }
    .sell { background: #ffa500; color: #fff; }

    .token-list { margin-top: 15px; }
    .token-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      border-radius: 10px;
      background: rgba(255,255,255,0.06);
      margin-bottom: 10px;
    }

    /* Left column: token symbol (with optional logo) on first line, full name below */
    .token-item > div:first-child {
      display: flex;
      flex-direction: column; /* symbol on top, name below */
      align-items: flex-start;
      gap: 6px;
    }
    /* Symbol row shows logo + ticker inline */
    .symbol {
      font-weight: bold;
      display:flex;
      align-items:center;
      gap:10px;
      font-size:15px;
    }

    /* Right column: amount on top, price below */
    .token-item > div:last-child {
      text-align: right;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
    }
    .token-amount { font-weight:800; }
    .price { color: #00ffae; font-weight: bold; }

    /* token image */
    .token-img { width:28px; height:28px; border-radius:50%; object-fit:cover; display:inline-block; vertical-align:middle; }

    /* price change */
    .pct-up { color: #4cd97b; font-weight:700; }
    .pct-down { color: #ff6b6b; font-weight:700; }

    /* PAYME testnet badge */
    .payme-badge {
      width:28px;height:28px;border-radius:50%;background:#1e90ff;color:#fff;display:inline-flex;
      align-items:center;justify-content:center;font-weight:800;font-size:12px;margin-right:8px;
    }

    .add-token-btn {
      display: inline-block;
      margin-top: 12px;
      padding: 10px 14px;
      background: #1e90ff;
      color: #fff;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      border: none;
      text-align: center;
    }

    .muted { color: rgba(255,255,255,0.65); font-size:13px; }

    /* keep horizontal layout on phones — do not convert actions or token rows to vertical */
    @media (max-width:420px){
      .token-item { /* keep row layout but allow wrapping if needed */
        flex-wrap: nowrap;
      }
      .actions { gap:8px; }
      .actions button { padding:10px 12px; min-width:70px; }
    }
  </style>
</head>
<body>
  <h1>Payme Crypto</h1>

  <div class="card">
    <div class="wallet-info">
      <div>Wallet Address</div>
      <div id="walletAddr" class="wallet-address">0x1234...abcd</div>
    </div>

    <div class="network-toggle">
      <button id="mainBtn" class="active" onclick="switchNetwork('mainnet')">Mainnet</button>
      <button id="testBtn" onclick="switchNetwork('testnet')">Testnet</button>
    </div>

    <div id="balance" class="balance">$0.00 (Mainnet)</div>

    <div class="actions">
      <button class="send">Send</button>
      <button class="receive" onclick="window.location.href='receive.html'">Receive</button>
      <button class="buy">Buy</button>
      <button class="sell">Sell</button>
    </div>
  </div>

  <div id="tokens" class="card token-list">
    <button class="add-token-btn" onclick="onAddTokenClicked()">+ Add Token (CoinGecko)</button>
    <div id="addTokenStatus" style="margin-top:8px;"></div>
  </div>

  <script>
    /*******************************
     * Backend integration (DO NOT change)
     *******************************/
    // <-- set this to your deployed backend (Render) URL
    const API_BASE = "https://paymecrypto-1.onrender.com";

    // small helper: call backend markets, fallback to CoinGecko
    async function fetchMarketsViaBackend(ids){
      if(!ids || ids.length===0) return [];
      const q = encodeURIComponent(ids.join(","));
      // try backend first
      try {
        const res = await fetch(`${API_BASE}/api/coins/markets?ids=${q}`);
        if(res.ok){
          const data = await res.json();
          if(Array.isArray(data)) return data;
        }
        // if backend returns something but not ok, fallback below
      } catch(e){
        // ignore and fallback
        console.warn("Backend markets call failed, falling back to CoinGecko", e);
      }
      // fallback direct to CoinGecko
      try {
        const res2 = await fetch("https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=" + q + "&price_change_percentage=24h");
        if(res2.ok){
          return await res2.json();
        }
      } catch(e2){
        console.warn("CoinGecko fallback failed", e2);
      }
      return [];
    }

    // search wrapper - backend -> fallback direct
    async function searchCoinGecko(q){
      if(!q) return { coins: [] };
      try {
        const res = await fetch(`${API_BASE}/api/coins/search?q=${encodeURIComponent(q)}`);
        if(res.ok){
          return await res.json();
        }
      } catch(e){
        console.warn("Backend search failed, fallback to CoinGecko", e);
      }
      // fallback
      const res2 = await fetch("https://api.coingecko.com/api/v3/search?query=" + encodeURIComponent(q));
      return await res2.json();
    }

    // call backend to fetch on-chain balances (preferred)
    async function fetchBalancesFromBackend(chainKey, address, coinIds = [], explicitTokens = []){
      try {
        const res = await fetch(`${API_BASE}/api/balance`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            chain: chainKey,
            address: address,
            coin_ids: coinIds,
            tokens: explicitTokens
          })
        });
        if(!res.ok) throw new Error("backend balance call failed");
        return await res.json();
      } catch(e){
        console.warn("fetchBalancesFromBackend failed:", e);
        return null;
      }
    }

    /***********************
     * Basic data & storage
     ***********************/
    const STORAGE_WALLET = "payme_wallet";
    const STORAGE_TOKENS = "payme_tokens"; // structure: { mainnet: { coinId: { symbol,name,balance } }, testnet: { PYM: { balance } } }

    // show derived wallet address (if any)
    const wallet = JSON.parse(localStorage.getItem(STORAGE_WALLET) || "{}");
    const walletAddress = (wallet && wallet.address) ? wallet.address : null;
    document.getElementById("walletAddr").innerText = walletAddress || "0x1234...abcd";

    // default mainnet tokens (CoinGecko ids)
    const DEFAULT_MAINNET_IDS = ["ethereum","binancecoin"]; // CoinGecko ids for ETH and BNB

    // minimal ERC20 ABI (for in-browser fallback)
    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function decimals() view returns (uint8)"
    ];

    // RPC providers for browser fallback (kept for compatibility if backend fails)
    const PROVIDERS = {
      eth: new ethers.JsonRpcProvider("https://cloudflare-eth.com"),
      bsc: new ethers.JsonRpcProvider("https://bsc-dataseed.binance.org/"),
      polygon: new ethers.JsonRpcProvider("https://rpc.ankr.com/polygon"),
      avax: new ethers.JsonRpcProvider("https://rpc.ankr.com/avalanche"),
      arbitrum: new ethers.JsonRpcProvider("https://rpc.ankr.com/arbitrum"),
      optimism: new ethers.JsonRpcProvider("https://rpc.ankr.com/optimism"),
      fantom: new ethers.JsonRpcProvider("https://rpc.ankr.com/fantom")
      // add more if you need
    };

    // map coinGecko platform key -> our provider keys (partial)
    const PLATFORM_TO_PROVIDER = {
      "ethereum": PROVIDERS.eth,
      "binance-smart-chain": PROVIDERS.bsc,
      "polygon-pos": PROVIDERS.polygon,
      "avalanche": PROVIDERS.avax,
      "arbitrum-one": PROVIDERS.arbitrum,
      "optimistic-ethereum": PROVIDERS.optimism,
      "fantom": PROVIDERS.fantom
    };

    // small helpers to read / write tokens
    function readStoredTokens(){
      try { return JSON.parse(localStorage.getItem(STORAGE_TOKENS) || "{}"); }
      catch(e) { return {}; }
    }
    function writeStoredTokens(obj){
      localStorage.setItem(STORAGE_TOKENS, JSON.stringify(obj));
    }
    function fmt(n){ return Number(n).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:8}); }

    /***********************
     * Row management (creates & updates token rows in-place)
     ***********************/
    const tokenRows = {}; // id -> {node, meta}

    function createOrUpdateRow(id, meta){
      // id is either coinId for mainnet or symbol key for testnet (e.g., PYM)
      // meta: { symbol, name, image, priceStr, price, pct, balance, isPayme }
      let entry = tokenRows[id];
      if(!entry){
        // create
        const container = document.getElementById("tokens");
        const row = document.createElement("div");
        row.className = "token-item";
        row.dataset.tokenId = id;

        // left
        const left = document.createElement("div");
        const sym = document.createElement("div");
        sym.className = "symbol";
        const imgWrap = document.createElement("span");
        if(meta.isPayme){
          imgWrap.innerHTML = `<span class="payme-badge">PY</span>`;
        } else if(meta.image){
          imgWrap.innerHTML = `<img class="token-img" src="${meta.image}" alt="${meta.symbol}">`;
        } else {
          imgWrap.innerHTML = `<div style="width:28px;height:28px;border-radius:50%;background:rgba(255,255,255,0.03);display:inline-block;margin-right:8px;"></div>`;
        }
        sym.appendChild(imgWrap);
        const symText = document.createElement("span");
        symText.style.marginLeft = "6px";
        symText.innerText = meta.symbol || id.toUpperCase();
        sym.appendChild(symText);
        left.appendChild(sym);
        const nameEl = document.createElement("div");
        nameEl.className = "muted";
        nameEl.style.fontSize = "13px";
        nameEl.innerText = meta.name || id;
        left.appendChild(nameEl);

        // right
        const right = document.createElement("div");
        const amountEl = document.createElement("div");
        amountEl.className = "token-amount";
        amountEl.innerText = `${fmt(meta.balance||0)} ${meta.symbol || id.toUpperCase()}`;
        const priceEl = document.createElement("div");
        priceEl.className = "price";
        priceEl.innerText = `$${meta.price ? fmt(meta.price) : (meta.priceStr || "0.00")}`;

        // pct
        const pctEl = document.createElement("div");
        pctEl.style.fontSize = "13px";
        if(typeof meta.pct === "number"){
          pctEl.innerText = `${meta.pct > 0 ? "+" : ""}${Number(meta.pct).toFixed(2)}%`;
          pctEl.className = meta.pct >= 0 ? "pct-up" : "pct-down";
        } else {
          pctEl.innerText = "";
        }

        right.appendChild(amountEl);
        right.appendChild(priceEl);
        right.appendChild(pctEl);

        row.appendChild(left);
        row.appendChild(right);

        // insert row after add button/status area (so add button remains at top)
        const tokensCard = document.getElementById("tokens");
        tokensCard.appendChild(row);

        tokenRows[id] = { node: row, meta: Object.assign({}, meta), els: { amountEl, priceEl, pctEl, nameEl, symText, imgWrap } };
        return;
      }

      // update existing row in-place (do not remove node)
      // update meta fields only if changed
      const els = entry.els;
      entry.meta = Object.assign({}, entry.meta || {}, meta);

      // update image if changed
      if(meta.isPayme){
        els.imgWrap.innerHTML = `<span class="payme-badge">PY</span>`;
      } else if(meta.image){
        // only replace src if different
        const prevImg = els.imgWrap.querySelector("img");
        if(prevImg){
          if(prevImg.src !== meta.image) prevImg.src = meta.image;
        } else {
          els.imgWrap.innerHTML = `<img class="token-img" src="${meta.image}" alt="${meta.symbol}">`;
        }
      } else {
        // keep existing placeholder if already present
        if(!els.imgWrap.querySelector("img") && !els.imgWrap.querySelector(".payme-badge")){
          els.imgWrap.innerHTML = `<div style="width:28px;height:28px;border-radius:50%;background:rgba(255,255,255,0.03);display:inline-block;margin-right:8px;"></div>`;
        }
      }

      if(meta.symbol) els.symText.innerText = meta.symbol;
      if(meta.name) els.nameEl.innerText = meta.name;
      if(typeof meta.balance !== "undefined") els.amountEl.innerText = `${fmt(meta.balance)} ${meta.symbol || ""}`;
      if(typeof meta.price !== "undefined" || meta.priceStr) els.priceEl.innerText = `$${meta.price ? fmt(meta.price) : (meta.priceStr || "0.00")}`;
      if(typeof meta.pct !== "undefined"){
        els.pctEl.innerText = `${meta.pct > 0 ? "+" : ""}${Number(meta.pct).toFixed(2)}%`;
        els.pctEl.className = meta.pct >= 0 ? "pct-up" : "pct-down";
      }
    }

    /***********************
     * Utilities used by pricing/balance flows
     ***********************/
    // find contract for coinId (fallback uses direct CoinGecko coin detail)
    async function findContractForCoinId(coinId){
      try {
        const res = await fetch(`https://api.coingecko.com/api/v3/coins/${encodeURIComponent(coinId)}?localization=false&tickers=false&market_data=false&community_data=false&developer_data=false&sparkline=false`);
        if(!res.ok) return null;
        const detail = await res.json();
        const platforms = detail.platforms || {};
        const order = ["ethereum","binance-smart-chain","polygon-pos","avalanche","arbitrum-one","optimistic-ethereum"];
        for(const pf of order){
          const addr = platforms[pf];
          if(addr && addr !== "") return { contract: addr, platform: pf };
        }
        // fallback any non-empty
        for(const k in platforms){
          if(platforms[k]) return { contract: platforms[k], platform: k };
        }
      } catch(e){
        console.warn("findContractForCoinId failed:", e);
      }
      return null;
    }

    // helper to get mainnet ids
    function getMainnetIds(stored){
      const storedMain = stored.mainnet ? Object.keys(stored.mainnet) : [];
      const idsSet = new Set([...DEFAULT_MAINNET_IDS, ...storedMain]);
      return Array.from(idsSet);
    }

    /***********************
     * Price & display update logic
     * (this is the code you provided earlier; I've wired it to use fetchMarketsViaBackend)
     ***********************/
    // Update prices and meta for visible tokens (in-place, resilient)
    async function updatePricesAndDisplay(net){
      const stored = readStoredTokens();

      if(net === 'mainnet'){
        const ids = getMainnetIds(stored);
        // if no ids but tokenRows already present, compute total from tokenRows
        if(ids.length === 0){
          let totalFallback = 0;
          for(const k of Object.keys(tokenRows)){
            const meta = tokenRows[k].meta || {};
            totalFallback += (Number(meta.balance || 0) * Number(meta.price || 0));
          }
          if(totalFallback > 0 && totalFallback < 0.01) document.getElementById("balance").innerText = `<$0.01 (Mainnet)`;
          else document.getElementById("balance").innerText = `$${fmt(totalFallback)} (Mainnet)`;
          return;
        }

        // fetch market data (via backend wrapper)
        let markets = [];
        try {
          markets = await fetchMarketsViaBackend(ids);
        } catch(err){
          console.warn("CoinGecko markets fetch failed", err);
          markets = [];
        }
        const marketMap = {};
        (markets || []).forEach(m => marketMap[m.id] = m);

        let totalUsd = 0;

        for(const id of ids){
          const m = marketMap[id];
          const existing = tokenRows[id];
          const prevMeta = existing ? existing.meta : (stored.mainnet && stored.mainnet[id] ? stored.mainnet[id] : {});

          const symbol = m ? (m.symbol || id).toUpperCase() : (prevMeta.symbol ? prevMeta.symbol : id.toUpperCase());
          const name = m ? (m.name || id) : (prevMeta.name ? prevMeta.name : id);
          const price = m ? Number(m.current_price || 0) : (prevMeta.price ? Number(prevMeta.price) : 0);
          const pct = m && typeof m.price_change_percentage_24h === 'number' ? Number(m.price_change_percentage_24h) : (prevMeta.pct ? Number(prevMeta.pct) : 0);
          const image = m && m.image ? m.image : (prevMeta.image || null);

          // prefer on-chain/stored balance if present; if none, keep previous meta balance (don't wipe)
          let bal = 0;
          if(stored.mainnet && stored.mainnet[id] && typeof stored.mainnet[id].balance !== 'undefined'){
            bal = Number(stored.mainnet[id].balance || 0);
          } else if(prevMeta && typeof prevMeta.balance !== 'undefined'){
            bal = Number(prevMeta.balance || 0);
          } else {
            bal = 0;
          }

          const meta = {
            symbol,
            name,
            image,
            priceStr: price ? fmt(price) : (prevMeta.priceStr || "0.00"),
            price,
            pct: pct || 0,
            balance: bal,
            isPayme:false
          };

          createOrUpdateRow(id, meta);
          totalUsd += bal * price;
        }

        if(totalUsd > 0 && totalUsd < 0.01) document.getElementById("balance").innerText = `<$0.01 (Mainnet)`;
        else document.getElementById("balance").innerText = `$${fmt(totalUsd)} (Mainnet)`;

      } else {
        const t = stored.testnet || {};
        const keys = Object.keys(t);
        if(keys.length === 0){
          // compute fallback total from tokenRows testnet entries if