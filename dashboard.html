<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Payme Crypto — Dashboard</title>

  <!-- ethers v6 UMD (for local on-chain calls if needed) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.6.0/dist/ethers.umd.min.js"></script>

  <style>
    /* Keep your original look & feel — minimal changes to add delete swipe UI */
    body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      background: linear-gradient(135deg,#0f2027,#203a43,#2c5364);
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 { margin: 10px 0 20px; font-size: 26px; color: #00ffae; }
    .card {
      background: rgba(255,255,255,0.05);
      border-radius: 16px;
      padding: 20px;
      width: 100%;
      max-width: 500px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      margin-bottom: 20px;
    }
    .wallet-info { text-align: center; margin-bottom: 15px; }
    .wallet-address {
      font-family: monospace;
      background: rgba(0,0,0,0.3);
      padding: 8px;
      border-radius: 10px;
      word-break: break-all;
      margin: 8px 0;
    }
    .network-toggle { display: flex; justify-content: center; gap: 12px; margin: 10px 0; }
    .network-toggle button {
      padding: 8px 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      background: #1b3a4b;
      color: #fff;
    }
    .network-toggle .active { background: #00ffae; color: #00221a; }
    .balance { font-size: 24px; font-weight: bold; margin: 15px 0; color: #00ffae; }

    /* ACTIONS horizontal always */
    .actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin: 15px 0;
      flex-direction: row;
      overflow-x:auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom:2px;
    }
    .actions button {
      flex: 1;
      min-width: 80px;
      padding: 12px 16px;
      font-size: 16px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      white-space: nowrap;
    }
    .send { background: #ff6b6b; color: #fff; }
    .receive { background: #32cd32; color: #fff; }
    .buy { background: #1e90ff; color: #fff; }
    .sell { background: #ffa500; color: #fff; }

    .token-list { margin-top: 15px; width:100%; max-width:500px; }

    /* wrapper that holds delete button and token row */
    .token-row {
      position: relative;
      overflow: hidden;
      border-radius: 10px;
      margin-bottom: 10px;
      background: transparent;
    }

    /* the delete button sits behind the token content on the right */
    .delete-btn {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      background: #ff4d4f;
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 8px 12px;
      font-weight:700;
      display: none; /* hidden until revealed */
      z-index: 1;
      cursor: pointer;
    }

    /* token content that slides left to reveal delete */
    .token-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      border-radius: 10px;
      background: rgba(255,255,255,0.06);
      transform: translateX(0);
      transition: transform 180ms ease;
      position: relative;
      z-index: 2;
      touch-action: pan-y;
    }

    /* left column */
    .token-item > div:first-child {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
    }
    .symbol {
      font-weight: bold;
      display:flex;
      align-items:center;
      gap:10px;
      font-size:15px;
    }

    .token-amount { font-weight:800; }
    .price { color: #00ffae; font-weight: bold; display:flex; gap:8px; align-items:center; }

    .pct {
      font-weight:700;
      padding:2px 6px;
      border-radius:6px;
      font-size:12px;
      color:#00180f;
    }
    .pct.up { background: #9fe6c8; color:#003018; }
    .pct.down { background: #ffd6d6; color:#4d0b00; }

    .token-img { width:28px; height:28px; border-radius:50%; object-fit:cover; display:inline-block; vertical-align:middle; }

    .payme-badge {
      width:28px;height:28px;border-radius:50%;background:#1e90ff;color:#fff;display:inline-flex;
      align-items:center;justify-content:center;font-weight:800;font-size:12px;margin-right:8px;
    }

    .add-token-btn {
      display: inline-block;
      margin-top: 12px;
      padding: 10px 14px;
      background: #1e90ff;
      color: #fff;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      border: none;
      text-align: center;
    }

    .muted { color: rgba(255,255,255,0.65); font-size:13px; }

    @media (max-width:420px){
      .actions button { padding:10px 12px; min-width:70px; }
      .token-item { padding:10px; }
    }
  </style>
</head>
<body>
  <h1>Payme Crypto</h1>

  <div class="card">
    <div class="wallet-info">
      <div>Wallet Address</div>
      <div id="walletAddr" class="wallet-address">0x1234...abcd</div>
    </div>

    <div class="network-toggle">
      <button id="mainBtn" class="active" onclick="switchNetwork('mainnet')">Mainnet</button>
      <button id="testBtn" onclick="switchNetwork('testnet')">Testnet</button>
    </div>

    <div id="balance" class="balance">$0.00 (Mainnet)</div>

    <div class="actions">
      <button class="send">Send</button>
      <button class="receive" onclick="window.location.href='receive.html'">Receive</button>
      <button class="buy">Buy</button>
      <button class="sell">Sell</button>
    </div>
  </div>

  <div id="tokens" class="card token-list">
    <button id="addTokenBtn" class="add-token-btn">+ Add Token (CoinGecko)</button>
    <div id="addTokenStatus" style="margin-top:8px;"></div>
    <!-- token rows will be appended here -->
  </div>

  <script>
    /*********************************************************
     * Configuration
     * - Change API_BASE to point to your backend if needed.
     *********************************************************/
    const API_BASE = "https://paymecrypto-1.onrender.com"; // change if different
    const STORAGE_WALLET = "payme_wallet";
    const STORAGE_TOKENS = "payme_tokens";

    // default mainnet coinGecko ids you want to show by default
    const DEFAULT_MAINNET_IDS = ["ethereum","binancecoin"];

    // minimal ERC20 ABI (used only if you want local ethers calls)
    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function decimals() view returns (uint8)"
    ];

    // providers mapping for client-side optional fallback (not required because backend fetches balances)
    const PROVIDERS = {
      eth: new ethers.JsonRpcProvider("https://cloudflare-eth.com"),
      bsc: new ethers.JsonRpcProvider("https://bsc-dataseed.binance.org/"),
      polygon: new ethers.JsonRpcProvider("https://rpc.ankr.com/polygon"),
      avax: new ethers.JsonRpcProvider("https://rpc.ankr.com/avalanche"),
      // add more if you like
    };

    // read wallet from localStorage (passkey.html saves there)
    const wallet = JSON.parse(localStorage.getItem(STORAGE_WALLET) || "{}");
    const walletAddress = wallet && wallet.address ? wallet.address : null;
    document.getElementById("walletAddr").innerText = walletAddress || "0x1234...abcd";

    // stored tokens structure: localStorage[STORAGE_TOKENS] = { mainnet: { coinId: {symbol,name,balance} }, testnet: {...} }
    function readStoredTokens(){
      try { return JSON.parse(localStorage.getItem(STORAGE_TOKENS) || "{}"); } catch(e){ return {}; }
    }
    function writeStoredTokens(obj){ localStorage.setItem(STORAGE_TOKENS, JSON.stringify(obj)); }

    function fmt(n){ return Number(n).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:8}); }

    // tokenRows: keep rows stable (no removal on refresh) - key -> { el, meta }
    const tokenRows = {}; // keys are coinId for mainnet, symbol for testnet

    // Utility: make a safe DOM element (small helper)
    function el(tag, className){ const e = document.createElement(tag); if(className) e.className = className; return e; }

    /***********************
     * Create or update row (in-place)
     ***********************/
    function createOrUpdateRow(key, meta){
      // meta: { symbol, name, image, priceStr, price, pct, balance, isPayme }
      // keep previous meta if missing fields
      const existing = tokenRows[key];

      if(existing){
        // update meta
        existing.meta = Object.assign({}, existing.meta || {}, meta);
        // update DOM parts (do not replace whole node)
        updateRowDOM(existing.el, existing.meta, key);
        return existing.el;
      }

      // create wrapper + delete button behind
      const wrapper = el('div','token-row');
      const deleteBtn = el('button','delete-btn');
      deleteBtn.innerText = "Delete";
      deleteBtn.title = "Delete token";
      wrapper.appendChild(deleteBtn);

      const row = el('div','token-item');
      row.setAttribute('data-key', key);

      // left
      const left = el('div');
      const symbolRow = el('div','symbol');
      const imgHtml = meta.image ? `<img class="token-img" src="${meta.image}" alt="${meta.symbol}">` : (meta.isPayme ? `<span class="payme-badge">PY</span>` : `<div style="width:28px;height:28px;border-radius:50%;background:rgba(255,255,255,0.03);display:inline-block;margin-right:8px;"></div>`);
      symbolRow.innerHTML = `${imgHtml} ${meta.symbol || key.toUpperCase()}`;
      const nameEl = el('div','muted');
      nameEl.style.fontSize = "13px";
      nameEl.innerText = meta.name || key;
      left.appendChild(symbolRow);
      left.appendChild(nameEl);

      // right
      const right = el('div');
      const amt = el('div','token-amount');
      amt.style.fontWeight = "800";
      amt.innerText = `${fmt(meta.balance||0)} ${meta.symbol||key.toUpperCase()}`;
      const priceRow = el('div','price');
      const priceSpan = el('span');
      priceSpan.innerText = `$${meta.price ? fmt(meta.price) : (meta.priceStr||"0.00")}`;
      const pctSpan = el('span','pct');
      pctSpan.style.display = "inline-block";
      const pctVal = Number(meta.pct || 0);
      pctSpan.innerText = (pctVal >= 0 ? "+" : "") + (pctVal ? Number(pctVal).toFixed(2) + "%" : "0.00%");
      pctSpan.className = "pct " + (pctVal >= 0 ? "up" : "down");
      priceRow.appendChild(priceSpan);
      priceRow.appendChild(pctSpan);
      right.appendChild(amt);
      right.appendChild(priceRow);

      row.appendChild(left);
      row.appendChild(right);

      wrapper.appendChild(row);
      const tokenContainer = document.getElementById("tokens");
      tokenContainer.appendChild(wrapper);

      // store
      tokenRows[key] = { el: row, wrapper, deleteBtn, meta };

      // attach click -> token details page
      row.addEventListener('click', (ev)=>{
        // only navigate if not in reveal / dragging or delete button clicked
        if(row.dataset.revealing === "1") return;
        // ignore clicks that started on delete button
        if(ev.target === deleteBtn) return;
        // navigate to token details, pass coin id & symbol & optional chain
        const params = new URLSearchParams();
        params.set('coin', key);
        // save meta snapshot so token.html can pick it up quickly
        localStorage.setItem('payme_last_token_meta', JSON.stringify(Object.assign({ key }, tokenRows[key].meta || {}) ));
        window.location.href = 'token.html?' + params.toString();
      });

      // delete button click
      deleteBtn.addEventListener('click', (e)=>{
        e.stopPropagation();
        // remove from storage and DOM
        const stored = readStoredTokens();
        const activeNet = document.getElementById("mainBtn").classList.contains("active") ? 'mainnet' : 'testnet';
        if(activeNet === 'mainnet' && stored.mainnet && stored.mainnet[key]){
          delete stored.mainnet[key];
          writeStoredTokens(stored);
        } else if(activeNet === 'testnet' && stored.testnet && stored.testnet[key]){
          delete stored.testnet[key];
          writeStoredTokens(stored);
        }
        // animate out
        wrapper.style.transition = 'opacity 150ms ease, height 150ms ease, margin 150ms ease';
        wrapper.style.opacity = 0;
        wrapper.style.height = '0px';
        wrapper.style.margin = '0px';
        setTimeout(()=>{ wrapper.remove(); delete tokenRows[key]; }, 200);
      });

      // swipe/drag to reveal delete (supports mouse & touch)
      attachSwipeReveal(row, deleteBtn);

      // initial DOM fill
      updateRowDOM(row, meta, key);

      return row;
    }

    function updateRowDOM(rowEl, meta, key){
      // rowEl is the .token-item element
      const left = rowEl.children[0];
      const right = rowEl.children[1];

      // update left symbol & name
      const symbolDiv = left.querySelector('.symbol');
      if(symbolDiv){
        const imgHtml = meta.image ? `<img class="token-img" src="${meta.image}" alt="${meta.symbol}">` : (meta.isPayme ? `<span class="payme-badge">PY</span>` : `<div style="width:28px;height:28px;border-radius:50%;background:rgba(255,255,255,0.03);display:inline-block;margin-right:8px;"></div>`);
        symbolDiv.innerHTML = `${imgHtml} ${meta.symbol || key.toUpperCase()}`;
      }
      const nameEl = left.querySelector('.muted');
      if(nameEl) nameEl.innerText = meta.name || key;

      // update right amount and price
      const amt = right.querySelector('.token-amount');
      if(amt) amt.innerText = `${fmt(meta.balance||0)} ${meta.symbol||key.toUpperCase()}`;
      const priceSpan = right.querySelector('.price span:first-child');
      if(priceSpan) priceSpan.innerText = `$${meta.price ? fmt(meta.price) : (meta.priceStr||"0.00")}`;

      const pctSpan = right.querySelector('.pct');
      if(pctSpan){
        const pctVal = Number(meta.pct || 0);
        pctSpan.innerText = (pctVal >= 0 ? "+" : "") + (pctVal ? Number(pctVal).toFixed(2) + "%" : "0.00%");
        pctSpan.className = "pct " + (pctVal >= 0 ? "up" : "down");
      }
    }

    /***********************
     * Swipe reveal helpers
     ***********************/
    function attachSwipeReveal(rowEl, deleteBtn){
      let startX = 0, curX = 0, dragging = false, revealed = false;
      const maxLeft = 90; // px translate left to reveal delete button area
      const threshold = 50;

      function setTranslate(x){
        // clamp between -maxLeft .. 0
        x = Math.max(-maxLeft, Math.min(0, x));
        rowEl.style.transform = `translateX(${x}px)`;
      }

      function onPointerDown(e){
        dragging = true;
        startX = (e.touches ? e.touches[0].clientX : e.clientX);
        curX = startX;
        rowEl.dataset.dragging = "1";
      }
      function onPointerMove(e){
        if(!dragging) return;
        const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
        const dx = clientX - startX;
        if(dx < 0){ // only permit left drag
          setTranslate(dx);
        } else {
          setTranslate(0);
        }
      }
      function onPointerUp(e){
        if(!dragging) return;
        dragging = false;
        rowEl.dataset.dragging = "0";
        const style = window.getComputedStyle(rowEl);
        const matrix = style.transform;
        // compute current translateX value
        let tx = 0;
        if(matrix && matrix !== 'none'){
          const vals = matrix.match(/matrix.*\((.+)\)/)[1].split(', ');
          tx = parseFloat(vals[4]);
        }
        if(Math.abs(tx) > threshold){
          // reveal
          setTranslate(-maxLeft);
          revealed = true;
          rowEl.dataset.revealing = "1";
          deleteBtn.style.display = "inline-block";
        } else {
          // snap back
          setTranslate(0);
          revealed = false;
          rowEl.dataset.revealing = "0";
          deleteBtn.style.display = "none";
        }
      }

      // support touch
      rowEl.addEventListener('touchstart', onPointerDown, {passive:true});
      rowEl.addEventListener('touchmove', onPointerMove, {passive:true});
      rowEl.addEventListener('touchend', onPointerUp);
      // mouse
      rowEl.addEventListener('mousedown', onPointerDown);
      window.addEventListener('mousemove', onPointerMove);
      window.addEventListener('mouseup', onPointerUp);

      // clicking elsewhere should close revealed
      document.addEventListener('click', (e)=>{
        if(revealed){
          const within = rowEl.contains(e.target) || deleteBtn.contains(e.target);
          if(!within){
            setTranslate(0);
            revealed = false;
            rowEl.dataset.revealing = "0";
            deleteBtn.style.display = "none";
          }
        }
      });
    }

    /***********************
     * Helper: get mainnet ids to fetch
     ***********************/
    function getMainnetIds(stored){
      const storedMain = stored.mainnet ? Object.keys(stored.mainnet) : [];
      const idsSet = new Set([...DEFAULT_MAINNET_IDS, ...storedMain]);
      return Array.from(idsSet);
    }

    /***********************
     * Update prices & display (in-place)
     * Uses backend /api/coins/markets via API_BASE
     ***********************/
    async function updatePricesAndDisplay(net){
      const stored = readStoredTokens();

      if(net === 'mainnet'){
        const ids = getMainnetIds(stored);
        // fallback when no ids: compute total from tokenRows
        if(ids.length === 0){
          let totalFallback = 0;
          for(const k of Object.keys(tokenRows)){
            const meta = tokenRows[k].meta || {};
            totalFallback += (Number(meta.balance || 0) * Number(meta.price || 0));
          }
          if(totalFallback > 0 && totalFallback < 0.01) document.getElementById("balance").innerText = `<$0.01 (Mainnet)`;
          else document.getElementById("balance").innerText = `$${fmt(totalFallback)} (Mainnet)`;
          return;
        }

        // call backend markets
        let markets = [];
        try {
          const url = `${API_BASE}/api/coins/markets?vs_currency=usd&ids=${encodeURIComponent(ids.join(","))}&price_change_percentage=24h`;
          const res = await fetch(url);
          markets = await res.json();
        } catch(err){
          console.warn("markets fetch failed", err);
          markets = [];
        }
        const marketMap = {};
        (markets || []).forEach(m => marketMap[m.id] = m);

        let totalUsd = 0;

        for(const id of ids){
          const m = marketMap[id];
          const existing = tokenRows[id];
          const prevMeta = existing ? existing.meta : (stored.mainnet && stored.mainnet[id] ? stored.mainnet[id] : {});

          const symbol = m ? (m.symbol || id).toUpperCase() : (prevMeta.symbol ? prevMeta.symbol : id.toUpperCase());
          const name = m ? (m.name || id) : (prevMeta.name ? prevMeta.name : id);
          const price = m ? Number(m.current_price || 0) : (prevMeta.price ? Number(prevMeta.price) : 0);
          const pct = m && typeof m.price_change_percentage_24h === 'number' ? Number(m.price_change_percentage_24h) : (prevMeta.pct ? Number(prevMeta.pct) : 0);
          const image = m && m.image ? m.image : (prevMeta.image || null);

          
          // prefer stored balance if present; else keep previous meta balance (don't wipe)
          let bal = 0;
          if(stored.mainnet && stored.mainnet[id] && typeof stored.mainnet[id].balance !== 'undefined'){
            bal = Number(stored.mainnet[id].balance || 0);
          } else if(prevMeta && typeof prevMeta.balance !== 'undefined'){
            bal = Number(prevMeta.balance || 0);
          } else {
            bal = 0;
          }

          const meta = {
            symbol,
            name,
            image,
            priceStr: price ? fmt(price) : (prevMeta.priceStr || "0.00"),
            price,
            pct: pct || 0,
            balance: bal,
            isPayme:false
          };

          createOrUpdateRow(id, meta);
          totalUsd += bal * price;
        }

        if(totalUsd > 0 && totalUsd < 0.01) document.getElementById("balance").innerText = `<$0.01 (Mainnet)`;
        else document.getElementById("balance").innerText = `$${fmt(totalUsd)} (Mainnet)`;

      } else {
        // testnet: only stored.testnet entries (like PYM)
        const t = stored.testnet || {};
        const keys = Object.keys(t);
        if(keys.length === 0){
          // fallback total from tokenRows testnet entries if present
          let fallback = 0;
          for(const k of Object.keys(tokenRows)){
            if(k === 'PYM' || (t && t[k])) {
              const meta = tokenRows[k] && tokenRows[k].meta ? tokenRows[k].meta : null;
              if(meta) fallback += (Number(meta.balance||0) * Number(meta.price||0));
            }
          }
          if(fallback > 0 && fallback < 0.01) document.getElementById("balance").innerText = `<$0.01 (Testnet)`;
          else document.getElementById("balance").innerText = `$${fmt(fallback)} (Testnet)`;
          return;
        }

        let total = 0;
        for(const k of keys){
          const item = t[k];
          const balStored = Number(item.balance || 0);
          const prevMeta = tokenRows[k] ? tokenRows[k].meta : {};
          const price = (k === "PYM") ? 0.5 : (item.price || prevMeta.price || 0);
          const meta = {
            symbol: k.toUpperCase(),
            name: item.name || (k === "PYM" ? "Testnet Token" : k),
            image: null,
            priceStr: fmt(price),
            price,
            pct: prevMeta ? (prevMeta.pct || 0) : 0,
            balance: typeof item.balance !== 'undefined' ? balStored : (prevMeta.balance || 0),
            isPayme: (k === "PYM")
          };
          createOrUpdateRow(k, meta);
          total += meta.balance * price;
        }
        if(total > 0 && total < 0.01) document.getElementById("balance").innerText = `<$0.01 (Testnet)`;
        else document.getElementById("balance").innerText = `$${fmt(total)} (Testnet)`;
      }
    }

    /***********************
     * Update on-chain balances using backend /api/balance
     * Backend will find contracts across chains and query them.
     ***********************/
    async function updateOnChainBalances(net){
      const stored = readStoredTokens();
      if(net === 'mainnet'){
        const ids = getMainnetIds(stored);
        if(!walletAddress || ids.length === 0) return;
        try {
          const body = {
            chain: "ethereum", // preferred for native display; but backend will use platform mapping for tokens
            address: walletAddress,
            coin_ids: ids
          };
          const res = await fetch(`${API_BASE}/api/balance`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body)
          });
          const json = await res.json();
          if(json && Array.isArray(json.tokens)){
            for(const tk of json.tokens){
              const id = tk.coin_id || (tk.symbol && tk.symbol.toLowerCase()) || null;
              // backend returns coin_id for CoinGecko ids -> ideal match
              if(!id) continue;
              const bal = Number(tk.balance || 0);
              // update stored
              const stored2 = readStoredTokens();
              stored2.mainnet = stored2.mainnet || {};
              stored2.mainnet[id] = stored2.mainnet[id] || {};
              stored2.mainnet[id].balance = bal;
              writeStoredTokens(stored2);
              // update row (createOrUpdateRow will keep previous meta)
              const existing = tokenRows[id];
              const prev = existing ? existing.meta : (stored2.mainnet && stored2.mainnet[id] ? stored2.mainnet[id] : {});
              createOrUpdateRow(id, {
                symbol: prev.symbol || (tk.symbol || id).toUpperCase(),
                name: prev.name || (tk.name || id),
                image: prev.image || tk.logo || null,
                priceStr: fmt(tk.usd_price || prev.price || 0),
                price: tk.usd_price || prev.price || 0,
                pct: tk.price_change_24h || prev.pct || 0,
                balance: bal,
                isPayme: false
              });
            }
          }
        } catch(e){
          console.warn("updateOnChainBalances failed", e);
        }
      } else {
        // Testnet: balances come from stored.testnet; no on-chain check by default
      }

      // recompute totals after update
      const activeNet = document.getElementById("mainBtn").classList.contains("active") ? 'mainnet' : 'testnet';
      await updatePricesAndDisplay(activeNet);
    }

    /***********************
     * Initial render helper
     ***********************/
    async function renderInitial(net){
      await updatePricesAndDisplay(net);
      if(walletAddress) {
        updateOnChainBalances(net).catch(()=>{});
      }
    }

    // attach add token
    document.getElementById('addTokenBtn').addEventListener('click', onAddTokenClicked);

    // Add token flow using backend search
    async function onAddTokenClicked(){
      const status = document.getElementById("addTokenStatus");
      status.innerText = "";
      try {
        const q = prompt("Search token on CoinGecko by name or symbol (e.g. 'uniswap' or 'uni'):");
        if(!q) return;
        status.innerText = "Searching CoinGecko...";
        const sres = await fetch(`${API_BASE}/api/coins/search?query=${encodeURIComponent(q)}`);
        const sjson = await sres.json();
        const coins = sjson.coins || [];
        if(coins.length === 0){
          alert("No matching token found on CoinGecko.");
          status.innerText = "";
          return;
        }
        let choices = coins.slice(0,6).map((c,i)=>`${i+1}. ${c.name} (${c.symbol}) : id=${c.id}`).join("\n");
        let pick = prompt("Choose a token by number (or press Cancel to pick first):\n\n" + choices, "1");
        let idx = 0;
        if(pick){
          const p = parseInt(pick,10);
          if(!isNaN(p) && p >= 1 && p <= Math.min(6, coins.length)) idx = p-1;
        }
        const coin = coins[idx];
        if(!coin || !coin.id){
          alert("Invalid selection.");
          status.innerText = "";
          return;
        }
        const stored = readStoredTokens();
        stored.mainnet = stored.mainnet || {};
        stored.mainnet[coin.id] = {
          symbol: coin.symbol.toUpperCase(),
          name: coin.name,
          balance: stored.mainnet && stored.mainnet[coin.id] ? stored.mainnet[coin.id].balance || 0 : 0
        };
        writeStoredTokens(stored);
        status.innerText = `Added ${coin.symbol.toUpperCase()} — balance will be detected from wallet (if connected).`;

        // update UI immediately: fetch markets for this id and create row
        await updatePricesAndDisplay("mainnet");
        if(walletAddress) updateOnChainBalances("mainnet").catch(()=>{});
      } catch (err) {
        console.error("Add token error", err);
        alert("Failed to add token.");
        document.getElementById("addTokenStatus").innerText = "";
      }
    }

    /***********************
     * Network switching
     ***********************/
    function switchNetwork(net){
      document.getElementById("mainBtn").classList.remove("active");
      document.getElementById("testBtn").classList.remove("active");
      if(net==="mainnet"){document.getElementById("mainBtn").classList.add("active");}
      else{document.getElementById("testBtn").classList.add("active");}
      renderInitial(net);
    }
    window.switchNetwork = switchNetwork;

    // Initial render default mainnet
    renderInitial("mainnet");

    // Fast price updates (every 3s)
    setInterval(async ()=>{
      const mainActive = document.getElementById("mainBtn").classList.contains("active");
      const net = mainActive ? "mainnet" : "testnet";
      await updatePricesAndDisplay(net);
    }, 3000);

    // On-chain balance updates every 6s
    setInterval(async ()=>{
      const mainActive = document.getElementById("mainBtn").classList.contains("active");
      if(mainActive && walletAddress){
        await updateOnChainBalances("mainnet");
      }
    }, 6000);

  </script>
</body>
</html>
