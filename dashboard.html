<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Payme Crypto â€” Dashboard</title>

  <!-- ethers v6 UMD (used to query RPCs & token contracts when needed) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.6.0/dist/ethers.umd.min.js"></script>

  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      background: linear-gradient(135deg,#0f2027,#203a43,#2c5364);
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 { margin: 10px 0 20px; font-size: 26px; color: #00ffae; }
    .card {
      background: rgba(255,255,255,0.05);
      border-radius: 16px;
      padding: 20px;
      width: 100%;
      max-width: 720px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      margin-bottom: 20px;
    }
    .wallet-info { text-align: center; margin-bottom: 15px; }
    .wallet-address {
      font-family: monospace;
      background: rgba(0,0,0,0.3);
      padding: 8px;
      border-radius: 10px;
      word-break: break-all;
      margin: 8px 0;
    }
    .network-toggle { display: flex; justify-content: center; gap: 12px; margin: 10px 0; }
    .network-toggle button {
      padding: 8px 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      background: #1b3a4b;
      color: #fff;
    }
    .network-toggle .active { background: #00ffae; color: #00221a; }
    .balance { font-size: 24px; font-weight: bold; margin: 15px 0; color: #00ffae; }

    /* ACTIONS: always horizontal (desktop & mobile) */
    .actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin: 15px 0;
      flex-direction: row; /* horizontal */
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 2px;
    }
    .actions button {
      flex: 1;
      min-width: 80px;
      padding: 12px 16px;
      font-size: 16px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      white-space: nowrap;
    }
    .send { background: #ff6b6b; color: #fff; }
    .receive { background: #32cd32; color: #fff; }
    .buy { background: #1e90ff; color: #fff; }
    .sell { background: #ffa500; color: #fff; }

    .token-list { margin-top: 15px; }
    .token-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      border-radius: 10px;
      background: rgba(255,255,255,0.06);
      margin-bottom: 10px;
      position: relative; /* for swipe delete */
      overflow: hidden;
      touch-action: pan-y;
    }

    /* Left column: token symbol (with optional logo) on first line, full name below */
    .token-item > div:first-child {
      display: flex;
      flex-direction: column; /* symbol on top, name below */
      align-items: flex-start;
      gap: 6px;
    }
    .symbol {
      font-weight: bold;
      display:flex;
      align-items:center;
      gap:10px;
      font-size:15px;
    }

    /* Right column: amount on top, price below */
    .token-item > div:last-child {
      text-align: right;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
    }
    .token-amount { font-weight:800; }
    .price { color: #00ffae; font-weight: bold; }

    /* token image */
    .token-img { width:28px; height:28px; border-radius:50%; object-fit:cover; display:inline-block; vertical-align:middle; }

    /* PAYME testnet badge */
    .payme-badge {
      width:28px;height:28px;border-radius:50%;background:#1e90ff;color:#fff;display:inline-flex;
      align-items:center;justify-content:center;font-weight:800;font-size:12px;margin-right:8px;
    }

    .add-token-btn {
      display: inline-block;
      margin-top: 12px;
      padding: 10px 14px;
      background: #1e90ff;
      color: #fff;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      border: none;
      text-align: center;
    }

    .muted { color: rgba(255,255,255,0.65); font-size:13px; }

    /* delete button that appears when swiped left (hidden by default) */
    .delete-btn {
      position: absolute;
      right: -80px;
      top: 50%;
      transform: translateY(-50%);
      background: #ff4d4f;
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 8px;
      font-weight:700;
      transition: right .2s ease;
      cursor:pointer;
    }

    /* when row has .show-delete, reveal delete button */
    .token-item.show-delete .delete-btn { right: 8px; }

    @media (max-width:420px){
      .token-item { flex-wrap: nowrap; }
      .actions { gap:8px; }
      .actions button { padding:10px 12px; min-width:70px; }
    }

    /* small settings row */
    .settings-row { display:flex; gap:10px; justify-content:center; align-items:center; margin:8px 0; flex-wrap:wrap; }
    .settings-row select, .settings-row label { font-size:13px; }
  </style>
</head>
<body>
  <h1>Payme Crypto</h1>

  <div class="card">
    <div class="wallet-info">
      <div>Wallet Address</div>
      <div id="walletAddr" class="wallet-address">0x1234...abcd</div>
    </div>

    <div class="network-toggle">
      <button id="mainBtn" class="active" onclick="switchNetwork('mainnet')">Mainnet</button>
      <button id="testBtn" onclick="switchNetwork('testnet')">Testnet</button>
    </div>

    <!-- NEW: settings row (preferred chain + backend-only toggle) -->
    <div class="settings-row">
      <label>
        Preferred backend chain:
        <select id="preferredChain" title="Preferred chain to send to backend (affects native display)">
          <option value="ethereum">Ethereum</option>
          <option value="bsc">BSC</option>
          <option value="polygon">Polygon</option>
          <option value="avax">Avalanche</option>
          <option value="arbitrum">Arbitrum</option>
          <option value="optimism">Optimism</option>
          <option value="fantom">Fantom</option>
          <option value="solana">Solana</option>
        </select>
      </label>

      <label style="display:flex;align-items:center;gap:6px;">
        <input type="checkbox" id="backendOnly" />
        Backend-only balances
      </label>
    </div>

    <div id="balance" class="balance">$0.00 (Mainnet)</div>

    <div class="actions">
      <button class="send">Send</button>
      <button class="receive" onclick="window.location.href='receive.html'">Receive</button>
      <button class="buy">Buy</button>
      <button class="sell">Sell</button>
    </div>
  </div>

  <div id="tokens" class="card token-list">
    <button class="add-token-btn" onclick="onAddTokenClicked()">+ Add Token (CoinGecko)</button>
    <div id="addTokenStatus" style="margin-top:8px;"></div>
    <!-- token rows appended here -->
  </div>

  <script>
    /***********************************************
     * BACKEND URL (your Render link)
     ***********************************************/
    const BACKEND_URL = "https://paymecrypto-1.onrender.com"; // change if needed

    /***********************
     * Data & storage keys
     ***********************/
    const STORAGE_WALLET = "payme_wallet";
    const STORAGE_TOKENS = "payme_tokens";

    // show derived wallet address (if any)
    const wallet = JSON.parse(localStorage.getItem(STORAGE_WALLET) || "{}");
    const walletAddress = wallet?.address || null;
    document.getElementById("walletAddr").innerText = walletAddress || "0x1234...abcd";

    // default mainnet tokens (CoinGecko ids)
    const DEFAULT_MAINNET_IDS = ["ethereum","binancecoin"];

    // minimal ERC20 ABI for JS-side contract usage (if needed)
    const ERC20_ABI = [
      "function balanceOf(address) view returns (uint256)",
      "function decimals() view returns (uint8)"
    ];

    // Providers (used when frontend does on-chain queries)
    const PROVIDERS = {
      eth: new ethers.JsonRpcProvider("https://cloudflare-eth.com"),
      bsc: new ethers.JsonRpcProvider("https://bsc-dataseed.binance.org/"),
      polygon: new ethers.JsonRpcProvider("https://rpc.ankr.com/polygon"),
      avax: new ethers.JsonRpcProvider("https://rpc.ankr.com/avalanche"),
      arbitrum: new ethers.JsonRpcProvider("https://rpc.ankr.com/arbitrum"),
      optimism: new ethers.JsonRpcProvider("https://rpc.ankr.com/optimism"),
      fantom: new ethers.JsonRpcProvider("https://rpc.ankr.com/fantom"),
    };

    const NATIVE_ID_TO_PROVIDER_KEY = {
      "ethereum": "eth",
      "binancecoin": "bsc",
      "polygon": "polygon",
      "avalanche-2": "avax",
      "arbitrum": "arbitrum",
      "optimism": "optimism",
      "fantom": "fantom"
    };

    // Token rows cache (keeps DOM and meta to prevent blinking)
    const tokenRows = {}; // keyed by coinId (mainnet) or token symbol (testnet PYM)

    // Utility: format number for display
    function fmt(n){ return Number(n).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:8}); }

    // Read/write stored tokens
    function readStoredTokens(){
      try { return JSON.parse(localStorage.getItem(STORAGE_TOKENS) || "{}"); }
      catch(e){ return {}; }
    }
    function writeStoredTokens(obj){ localStorage.setItem(STORAGE_TOKENS, JSON.stringify(obj)); }

    /***********************
     * Helpers: UI settings
     ***********************/
    function getPreferredChain(){
      const sel = document.getElementById("preferredChain");
      if(!sel) return "ethereum";
      return sel.value || "ethereum";
    }
    function isBackendOnly(){
      const chk = document.getElementById("backendOnly");
      return !!(chk && chk.checked);
    }

    // persist user's preferred chain between reloads (optional)
    (function restoreSettings(){
      const saved = localStorage.getItem("payme_pref_chain");
      if(saved){
        const sel=document.getElementById("preferredChain");
        if(sel) sel.value = saved;
      }
      const savedBackendOnly = localStorage.getItem("payme_backend_only");
      if(savedBackendOnly === "true"){
        document.getElementById("backendOnly").checked = true;
      }
    })();
    document.getElementById("preferredChain").addEventListener("change", (e)=>{
      localStorage.setItem("payme_pref_chain", e.target.value);
      // re-render using new chain preference
      renderInitial(document.getElementById("mainBtn").classList.contains("active") ? "mainnet" : "testnet");
    });
    document.getElementById("backendOnly").addEventListener("change",(e)=>{
      localStorage.setItem("payme_backend_only", e.target.checked ? "true" : "false");
      renderInitial(document.getElementById("mainBtn").classList.contains("active") ? "mainnet" : "testnet");
    });

    /***********************
     * Backend-aware wrappers
     ***********************/
    async function fetchMarkets(ids){
      if(!ids || ids.length === 0) return [];
      const q = encodeURIComponent(ids.join(","));
      if(BACKEND_URL){
        try {
          const res = await fetch(`${BACKEND_URL}/api/coins/markets?ids=${q}`);
          if(res.ok) return await res.json();
        } catch(e){
          console.warn("Backend markets call failed, falling back to CoinGecko:", e);
        }
      }
      try {
        const res = await fetch("https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=" + q + "&price_change_percentage=24h");
        return await res.json();
      } catch(e){
        console.warn("CoinGecko markets fetch failed", e);
        return [];
      }
    }

    async function fetchSearch(q){
      if(!q) return { coins: [] };
      const enc = encodeURIComponent(q);
      if(BACKEND_URL){
        try {
          const res = await fetch(`${BACKEND_URL}/api/coins/search?q=${enc}`);
          if(res.ok) return await res.json();
        } catch(e){
          console.warn("Backend search failed, falling back to CoinGecko:", e);
        }
      }
      try {
        const res = await fetch("https://api.coingecko.com/api/v3/search?query=" + enc);
        return await res.json();
      } catch(e){
        console.warn("CoinGecko search failed", e);
        return { coins: [] };
      }
    }

    async function fetchBalancesFromBackend(chainKey, address, coinIds){
      if(!BACKEND_URL) return null;
      try {
        const body = { chain: chainKey || getPreferredChain() || "ethereum", address: address, coin_ids: coinIds || [] };
        const res = await fetch(BACKEND_URL + "/api/balance", {
          method: "POST",
          headers: {"Content-Type":"application/json"},
          body: JSON.stringify(body)
        });
        if(!res.ok) return null;
        return await res.json();
      } catch(e){
        console.warn("Backend balance fetch failed", e);
        return null;
      }
    }

    /***********************
     * DOM: create or update row (non-destructive)
     ***********************/
    function createOrUpdateRow(idKey, meta){
      const container = document.getElementById("tokens");
      let entry = tokenRows[idKey];
      if(!entry){
        const row = document.createElement("div");
        row.className = "token-item";
        row.dataset.key = idKey;

        const left = document.createElement("div");
        const right = document.createElement("div");

        const del = document.createElement("button");
        del.className = "delete-btn";
        del.textContent = "Delete";
        del.onclick = (e)=>{
          e.stopPropagation();
          const stored = readStoredTokens();
          if(document.getElementById("mainBtn").classList.contains("active")){
            if(stored.mainnet && stored.mainnet[idKey]) { delete stored.mainnet[idKey]; writeStoredTokens(stored); }
          } else {
            if(stored.testnet && stored.testnet[idKey]) { delete stored.testnet[idKey]; writeStoredTokens(stored); }
          }
          row.remove();
          delete tokenRows[idKey];
        };

        row.appendChild(left);
        row.appendChild(right);
        row.appendChild(del);

        // swipe handlers to reveal delete
        let startX = null;
        row.addEventListener('touchstart', (ev)=>{ startX = ev.touches[0].clientX; }, {passive:true});
        row.addEventListener('touchmove', (ev)=>{
          if(startX === null) return;
          const dx = ev.touches[0].clientX - startX;
          if(dx < -30) row.classList.add('show-delete');
        }, {passive:true});
        row.addEventListener('touchend', ()=>{ startX = null; });

        // mouse drag for desktop
        let mdown=false, mxStart=0;
        row.addEventListener('mousedown', (e)=>{ mdown=true; mxStart=e.clientX; });
        window.addEventListener('mousemove',(e)=>{ if(!mdown) return; const dx=e.clientX-mxStart; if(dx < -30) row.classList.add('show-delete'); });
        window.addEventListener('mouseup', ()=>{ mdown=false; });

        // click opens detail page with chain param
        row.addEventListener('click', ()=>{
          const preferredChain = getPreferredChain();
          const params = new URLSearchParams({ key: idKey, net: document.getElementById("mainBtn").classList.contains("active") ? "mainnet" : "testnet", chain: preferredChain });
          window.open("token.html?" + params.toString(), "_blank");
        });

        // append after add button (add button is first child)
        container.appendChild(row);
        entry = { row, left, right, del, meta: {} };
        tokenRows[idKey] = entry;
      }

      // update DOM in-place
      const left = entry.left;
      const right = entry.right;

      left.innerHTML = `
        <div class="symbol">
          ${meta.image ? `<img class="token-img" src="${meta.image}" alt="${meta.symbol}">` : (meta.isPayme ? `<span class="payme-badge">PY</span>` : `<div style="width:28px;height:28px;border-radius:50%;background:rgba(255,255,255,0.03);display:inline-block;margin-right:8px;"></div>`)}
          ${meta.symbol}
        </div>
        <div class="muted">${meta.name || ""}</div>
      `;

      const pct = typeof meta.pct === 'number' ? meta.pct : 0;
      const pctStr = (pct >= 0 ? "+" : "") + Number(pct).toFixed(2) + "%";
      const pctHtml = `<div style="font-size:12px; ${pct < 0 ? 'color:#ff7b7b' : 'color:#9fe6c8'}">${pctStr}</div>`;

      right.innerHTML = `
        <div class="token-amount">${fmt(meta.balance || 0)} ${meta.symbol}</div>
        <div style="display:flex;align-items:center;gap:8px;justify-content:flex-end">
          <div class="price">$${meta.price ? fmt(meta.price) : meta.priceStr || "0.00"}</div>
          ${pctHtml}
        </div>
      `;

      entry.meta = meta;
    }

    /***********************
     * getMainnetIds helper
     ***********************/
    function getMainnetIds(stored){
      const storedMain = stored.mainnet ? Object.keys(stored.mainnet) : [];
      const idsSet = new Set([...DEFAULT_MAINNET_IDS, ...storedMain]);
      return Array.from(idsSet);
    }

    /***********************
     * updatePricesAndDisplay (non-destructive)
     ***********************/
    async function updatePricesAndDisplay(net){
      const stored = readStoredTokens();

      if(net === 'mainnet'){
        const ids = getMainnetIds(stored);
        if(ids.length === 0){
          let totalFallback = 0;
          for(const k of Object.keys(tokenRows)){
            const meta = tokenRows[k].meta || {};
            totalFallback += (Number(meta.balance || 0) * Number(meta.price || 0));
          }
          if(totalFallback > 0 && totalFallback < 0.01) document.getElementById("balance").innerText = `<$0.01 (Mainnet)`;
          else document.getElementById("balance").innerText = `$${fmt(totalFallback)} (Mainnet)`;
          return;
        }

        let markets = [];
        try {
          markets = await fetchMarkets(ids);
        } catch(err){
          console.warn("markets fetch failed:", err);
          markets = [];
        }
        const marketMap = {};
        (markets || []).forEach(m => marketMap[m.id] = m);

        let totalUsd = 0;

        for(const id of ids){
          const m = marketMap[id];
          const existing = tokenRows[id];
          const prevMeta = existing ? existing.meta : (stored.mainnet && stored.mainnet[id] ? stored.mainnet[id] : {});

          const symbol = m ? (m.symbol || id).toUpperCase() : (prevMeta.symbol ? prevMeta.symbol : id.toUpperCase());
          const name = m ? (m.name || id) : (prevMeta.name ? prevMeta.name : id);
          const price = m ? Number(m.current_price || 0) : (prevMeta.price ? Number(prevMeta.price) : 0);
          const pct = m && typeof m.price_change_percentage_24h === 'number' ? Number(m.price_change_percentage_24h) : (prevMeta.pct ? Number(prevMeta.pct) : 0);
          const image = m && m.image ? m.image : (prevMeta.image || null);

          let bal = 0;
          if(stored.mainnet && stored.mainnet[id] && typeof stored.mainnet[id].balance !== 'undefined'){
            bal = Number(stored.mainnet[id].balance || 0);
          } else if(prevMeta && typeof prevMeta.balance !== 'undefined'){
            bal = Number(prevMeta.balance || 0);
          } else {
            bal = 0;
          }

          const meta = {
            symbol,
            name,
            image,
            priceStr: price ? fmt(price) : (prevMeta.priceStr || "0.00"),
            price,
            pct: pct || 0,
            balance: bal,
            isPayme:false
          };

          createOrUpdateRow(id, meta);
          totalUsd += bal * price;
        }

        if(totalUsd > 0 && totalUsd < 0.01) document.getElementById("balance").innerText = `<$0.01 (Mainnet)`;
        else document.getElementById("balance").innerText = `$${fmt(totalUsd)} (Mainnet)`;

      } else {
        const t = stored.testnet || {};
        const keys = Object.keys(t);
        if(keys.length === 0){
          let fallback = 0;
          for