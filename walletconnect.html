<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>WalletConnect | Payme Crypto</title>

  <!-- WalletConnect provider (UMD), modal + ethers -->
  <script src="https://unpkg.com/@walletconnect/ethereum-provider@2.11.0/dist/index.umd.min.js"></script>
  <script src="https://unpkg.com/@walletconnect/modal@2.6.2/dist/index.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.6.0/dist/ethers.umd.min.js"></script>

  <style>
    :root {
      --bg: linear-gradient(180deg,#031620,#072a34);
      --text: #ecf9f2;
      --accent: #00d27a;
      --muted: #96b1ad;
    }
    body {
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      font-family: Inter, system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    .wrap {
      text-align:center;
      max-width:520px;
      width:100%;
      background:rgba(255,255,255,0.05);
      padding:24px;
      border-radius:16px;
      box-shadow:0 6px 24px rgba(0,0,0,0.6);
    }
    h1 {
      font-size:22px;
      margin-bottom:14px;
      color: var(--accent);
    }
    .btn {
      padding:12px 18px;
      font-size:15px;
      font-weight:700;
      border:0;
      border-radius:10px;
      background:var(--accent);
      color:#042e21;
      cursor:pointer;
      margin-top:16px;
    }
    #status {
      margin-top:14px;
      font-size:14px;
      color:var(--muted);
      word-break:break-word;
    }
    .small { font-size:13px; color: #9fb7ad; margin-top:6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Connect with WalletConnect</h1>
    <button id="connectBtn" class="btn">Connect Wallet</button>
    <div id="status">No wallet connected</div>
    <div class="small">After connecting we will fetch on-chain balances from your backend and redirect to the dashboard.</div>
  </div>

  <script>
  (async function(){
    const connectBtn = document.getElementById("connectBtn");
    const statusEl   = document.getElementById("status");

    // === CONFIG ===
    // Your WalletConnect Project ID (you provided it earlier)
    const PROJECT_ID = "48a4f7dc44d18bf848a1128ae145eb89";

    // Backend endpoint (your Render URL)
    const BACKEND_BASE = "https://paymecrypto-1.onrender.com";
    const BACKEND_BALANCE_ENDPOINT = BACKEND_BASE.replace(/\/$/, "") + "/api/balance";

    // map chainId (decimal) -> backend chain key
    // extend as needed; backend expects keys like 'ethereum','bsc','polygon','avax','arbitrum','optimism','solana', etc.
    const CHAIN_ID_TO_CHAIN_KEY = {
      1: "ethereum",
      56: "bsc",
      137: "polygon",
      43114: "avax",
      10: "optimism",
      42161: "arbitrum",
      250: "fantom",
      25: "cronos",
      // add more if you use them
    };

    // localStorage keys
    const LS_KEY_WC = "payme_walletconnect";
    const LS_KEY_BACKEND_BAL = "payme_backend_balance";

    // helper: show status
    function setStatus(msg, muted=false){
      statusEl.textContent = msg;
      statusEl.style.color = muted ? "var(--muted)" : "";
    }

    // init provider
    let provider;
    try {
      if(!window.WalletConnectEthereumProvider){
        setStatus("WalletConnect provider script failed to load. Check network/ CDN.", false);
        console.error("WalletConnectEthereumProvider missing");
        return;
      }

      const { EthereumProvider } = window.WalletConnectEthereumProvider;

      provider = await EthereumProvider.init({
        projectId: PROJECT_ID,
        chains: [1, 137, 56, 43114, 10, 42161], // most common EVM chains
        showQrModal: true,
      });

      // good
      setStatus("Provider initialized. Click connect.", true);
    } catch(err){
      console.error("Provider init error:", err);
      setStatus("Provider failed to initialize. See console for details.");
      return;
    }

    // helper: convert chain value to decimal number
    function parseChainId(chainVal){
      if(typeof chainVal === "number") return chainVal;
      try {
        if(typeof chainVal === "string"){
          if(chainVal.startsWith("0x")) return parseInt(chainVal, 16);
          return parseInt(chainVal,10);
        }
      } catch(e){}
      return null;
    }

    async function fetchBackendBalance(chainKey, address){
      try {
        setStatus("Fetching balances from backend...", true);
        const body = {
          chain: chainKey,
          address: address,
          coin_ids: [] , // optional: you can pass coin ids you want prices for
          tokens: []     // optional explicit contracts
        };
        const resp = await fetch(BACKEND_BALANCE_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
          credentials: "omit"
        });
        if(!resp.ok){
          const txt = await resp.text().catch(()=>"");
          throw new Error(`Backend error ${resp.status}: ${txt}`);
        }
        const data = await resp.json();
        return data;
      } catch(e){
        console.error("fetchBackendBalance error:", e);
        throw e;
      }
    }

    async function connectWallet(){
      try {
        setStatus("Connecting to wallet…", true);
        // open modal (provider.connect will prompt)
        await provider.connect();

        // request accounts & chain
        const accounts = await provider.request({ method: "eth_accounts" });
        if(!accounts || accounts.length === 0) {
          throw new Error("No accounts returned from provider.");
        }
        const address = accounts[0];

        // chainId can be hex or decimal string, so normalize
        let chainIdRaw;
        try { chainIdRaw = await provider.request({ method: "eth_chainId" }); } catch(e){ chainIdRaw = null; }
        const chainIdNum = parseChainId(chainIdRaw);
        const chainKey = (chainIdNum && CHAIN_ID_TO_CHAIN_KEY[chainIdNum]) ? CHAIN_ID_TO_CHAIN_KEY[chainIdNum] : "ethereum";

        // Save minimal wallet connect info
        const walletData = {
          address,
          chainId: chainIdRaw || null,
          chainKey,
          connectedAt: Date.now()
        };
        localStorage.setItem(LS_KEY_WC, JSON.stringify(walletData));
        setStatus(`Connected: ${address} (chain ${chainIdNum || chainIdRaw})`, true);

        // call backend to fetch balances (non-blocking UX but do await so dashboard gets data)
        let backendData = null;
        try {
          backendData = await fetchBackendBalance(chainKey, address);
          localStorage.setItem(LS_KEY_BACKEND_BAL, JSON.stringify(backendData));
          setStatus("Balances fetched. Redirecting to dashboard...", true);
        } catch(e) {
          // store minimal info so dashboard can still try
          localStorage.removeItem(LS_KEY_BACKEND_BAL);
          setStatus("Connected — backend fetch failed; opening dashboard (dashboard will retry).");
        }

        // small delay then go to dashboard
        setTimeout(()=>{ window.location.href = "dashboard.html"; }, 900);
      } catch(e){
        console.error("connectWallet failed:", e);
        setStatus("Connection failed: " + (e && e.message ? e.message : e));
      }
    }

    async function disconnectWallet(){
      try {
        setStatus("Disconnecting…", true);
        // call provider disconnect
        if(provider && provider.disconnect) {
          try { await provider.disconnect(); } catch(e){ /* ignore */ }
        }
        // clear stored data
        localStorage.removeItem(LS_KEY_WC);
        localStorage.removeItem(LS_KEY_BACKEND_BAL);
        setStatus("Disconnected");
        connectBtn.textContent = "Connect Wallet";
      } catch(e){
        console.error("disconnect error:", e);
      }
    }

    // Bind UI
    connectBtn.addEventListener("click", async ()=>{
      try {
        // If already connected: disconnect
        // provider.session (some builds) or provider.session?.connected
        const alreadyConnected = provider && provider.session && provider.session.connected;
        if(alreadyConnected){
          await disconnectWallet();
        } else {
          await connectWallet();
        }
      } catch(e){
        console.error(e);
      }
    });

    // Provider events: keep localStorage in sync
    try {
      provider.on && provider.on("accountsChanged", (acc) => {
        if(acc && acc.length) {
          setStatus("Accounts changed: " + acc[0]);
          const raw = JSON.parse(localStorage.getItem(LS_KEY_WC) || "{}");
          raw.address = acc[0];
          raw.connectedAt = Date.now();
          localStorage.setItem(LS_KEY_WC, JSON.stringify(raw));
        }
      });
      provider.on && provider.on("chainChanged", async (chainVal) => {
        const chainNum = parseChainId(chainVal);
        const chainKey = (chainNum && CHAIN_ID_TO_CHAIN_KEY[chainNum]) ? CHAIN_ID_TO_CHAIN_KEY[chainNum] : "ethereum";
        setStatus("Chain changed: " + (chainNum || chainVal));
        const wcRaw = JSON.parse(localStorage.getItem(LS_KEY_WC) || "{}");
        wcRaw.chainId = chainVal;
        wcRaw.chainKey = chainKey;
        localStorage.setItem(LS_KEY_WC, JSON.stringify(wcRaw));

        // fetch new balances for new chain if address known
        const addr = wcRaw.address;
        if(addr){
          try {
            const bdata = await fetchBackendBalance(chainKey, addr);
            localStorage.setItem(LS_KEY_BACKEND_BAL, JSON.stringify(bdata));
          } catch (e) {
            console.warn("failed to fetch balances after chain change", e);
          }
        }
      });
      provider.on && provider.on("disconnect", () => {
        // clear state when disconnected remotely
        localStorage.removeItem(LS_KEY_WC);
        localStorage.removeItem(LS_KEY_BACKEND_BAL);
        setStatus("Disconnected (remote)");
        connectBtn.textContent = "Connect Wallet";
      });
    } catch(e){
      // non-fatal
      console.warn("provider event wiring failed", e);
    }

    // If a session already exists (e.g. user previously connected) reflect status
    try {
      const accountsNow = await provider.request({ method: "eth_accounts" }).catch(()=>[]);
      if(accountsNow && accountsNow.length > 0){
        const address = accountsNow[0];
        const chainIdRaw = await provider.request({ method: "eth_chainId" }).catch(()=>null);
        const chainIdNum = parseChainId(chainIdRaw);
        const chainKey = (chainIdNum && CHAIN_ID_TO_CHAIN_KEY[chainIdNum]) ? CHAIN_ID_TO_CHAIN_KEY[chainIdNum] : "ethereum";
        localStorage.setItem(LS_KEY_WC, JSON.stringify({ address, chainId: chainIdRaw, chainKey, connectedAt: Date.now() }));
        setStatus("Session active: " + address, true);
        connectBtn.textContent = "Disconnect";
      }
    } catch(e){ /* ignore */ }

  })();
  </script>
</body>
</html>