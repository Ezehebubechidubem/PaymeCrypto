<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WalletConnect | Payme Crypto</title>

  <!-- WalletConnect v2 (Ethereum provider) -->
  <script src="https://unpkg.com/@walletconnect/ethereum-provider@2.11.0/dist/index.umd.min.js"></script>
  <script src="https://unpkg.com/ethers@6.6.0/dist/ethers.umd.min.js"></script>

  <style>
    :root {
      --bg: linear-gradient(180deg,#031620,#072a34);
      --text: #ecf9f2;
      --accent: #00d27a;
      --muted: #96b1ad;
    }
    body {
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      font-family: Inter, system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    .wrap {
      text-align:center;
      max-width:420px;
      background:rgba(255,255,255,0.05);
      padding:24px;
      border-radius:16px;
      box-shadow:0 6px 24px rgba(0,0,0,0.6);
    }
    h1 {
      font-size:22px;
      margin-bottom:14px;
      color: var(--accent);
    }
    .btn {
      padding:12px 18px;
      font-size:15px;
      font-weight:700;
      border:0;
      border-radius:10px;
      background:var(--accent);
      color:#042e21;
      cursor:pointer;
      margin-top:16px;
    }
    #status {
      margin-top:14px;
      font-size:14px;
      color:var(--muted);
      word-break: break-all;
    }
    .note {
      margin-top:10px;
      font-size:12px;
      color: #cde6d6;
    }
  </style>
</head>
<body>
  <div class="wrap" role="main" aria-labelledby="title">
    <h1 id="title">Connect with WalletConnect</h1>
    <button id="connectBtn" class="btn">Connect Wallet</button>
    <div id="status">No wallet connected</div>
    <div class="note">After connecting you will be redirected to the dashboard.</div>
  </div>

  <script>
  (async function(){
    const connectBtn = document.getElementById("connectBtn");
    const statusEl   = document.getElementById("status");

    // âœ… Your WalletConnect Cloud Project ID (provided)
    const projectId = "48a4f7dc44d18bf848a1128ae145eb89";

    if(!projectId || projectId.trim().length === 0){
      statusEl.textContent = "Missing WalletConnect Project ID. Please add it to the page.";
      connectBtn.disabled = true;
      return;
    }

    // Ensure provider library loaded
    if(!window.WalletConnectEthereumProvider){
      statusEl.textContent = "WalletConnect provider failed to load. Check your network and script include.";
      connectBtn.disabled = true;
      return;
    }

    // Create provider instance
    let provider;
    try {
      provider = await window.WalletConnectEthereumProvider.init({
        projectId,
        chains: [1, 137, 56, 43114], // Ethereum, Polygon, BSC, Avalanche (you can add more chain IDs)
        showQrModal: true,
        methods: ["eth_requestAccounts", "eth_chainId", "personal_sign", "eth_sign"],
      });
    } catch (err) {
      console.error("Provider init failed", err);
      statusEl.textContent = "Provider initialization failed: " + (err && err.message ? err.message : err);
      connectBtn.disabled = true;
      return;
    }

    // Helper to check connection & update UI
    async function refreshStatus(){
      try {
        // eth_accounts may return [] if not connected
        let accounts = [];
        try { accounts = await provider.request({ method: "eth_accounts" }); } catch(e){ accounts = []; }
        let chainId = null;
        try { chainId = await provider.request({ method: "eth_chainId" }); } catch(e){ chainId = null; }

        if(accounts && accounts.length > 0){
          const address = accounts[0];
          const displayChain = chainId ? (typeof chainId === "string" ? parseInt(chainId, 16) : chainId) : "unknown";
          statusEl.textContent = `Connected: ${address} (Chain ${displayChain})`;
          connectBtn.textContent = "Disconnect";
        } else {
          statusEl.textContent = "No wallet connected";
          connectBtn.textContent = "Connect Wallet";
        }
      } catch (e) {
        console.warn("refreshStatus failed", e);
      }
    }

    // Connect flow
    async function connectWallet(){
      try {
        // provider.connect() will open modal if needed
        await provider.connect();

        // prefer eth_accounts, fallback to eth_requestAccounts
        let accounts = [];
        try { accounts = await provider.request({ method: "eth_accounts" }); } catch(e){ accounts = []; }
        if(!accounts || accounts.length === 0){
          try { accounts = await provider.request({ method: "eth_requestAccounts" }); } catch(e){ accounts = []; }
        }

        if(!accounts || accounts.length === 0){
          statusEl.textContent = "Connected but no accounts returned.";
          return;
        }

        const address = accounts[0];
        let chainId = null;
        try { chainId = await provider.request({ method: "eth_chainId" }); } catch(e){ chainId = null; }

        // Save minimal connection info for dashboard to read
        localStorage.setItem("payme_walletconnect", JSON.stringify({
          address,
          chainId,
          connectedAt: Date.now()
        }));

        // update UI & redirect
        const displayChain = chainId ? (typeof chainId === "string" ? parseInt(chainId,16) : chainId) : "unknown";
        statusEl.textContent = `Connected: ${address} (Chain ${displayChain})`;
        connectBtn.textContent = "Disconnect";

        // small delay so user sees status
        setTimeout(()=>{ window.location.href = "dashboard.html"; }, 900);
      } catch (err) {
        console.error("connectWallet error", err);
        statusEl.textContent = "Connection failed: " + (err && err.message ? err.message : err);
      }
    }

    // Disconnect flow
    async function disconnectWallet(){
      try {
        // attempt graceful disconnect
        if(provider && provider.disconnect){
          try { await provider.disconnect(); } catch(e){ /* ignore */ }
        }
        // also try close
        if(provider && provider.close){
          try { await provider.close(); } catch(e){ /* ignore */ }
        }
      } catch(e){
        console.warn("disconnect errors", e);
      } finally {
        localStorage.removeItem("payme_walletconnect");
        statusEl.textContent = "Disconnected";
        connectBtn.textContent = "Connect Wallet";
      }
    }

    // Button toggles connect/disconnect
    connectBtn.addEventListener("click", async ()=>{
      try {
        // Some provider builds expose session.connected; check both
        const isConnected = !!(provider && ((provider.session && provider.session.connected) || provider.connected));
        if(isConnected){
          await disconnectWallet();
        } else {
          await connectWallet();
        }
      } catch(e){
        console.error(e);
      }
    });

    // Attach provider events (if supported)
    try {
      provider.on && provider.on("accountsChanged", (accounts) => {
        if(accounts && accounts.length > 0){
          statusEl.textContent = "Accounts changed: " + accounts[0];
          localStorage.setItem("payme_walletconnect", JSON.stringify({
            address: accounts[0],
            chainId: null,
            connectedAt: Date.now()
          }));
        } else {
          statusEl.textContent = "No accounts";
        }
      });

      provider.on && provider.on("chainChanged", (chain) => {
        const displayChain = (typeof chain === "string") ? parseInt(chain, 16) : chain;
        statusEl.textContent = "Chain changed: " + displayChain;
        // update stored chainId if present
        try {
          const st = JSON.parse(localStorage.getItem("payme_walletconnect") || "{}");
          st.chainId = chain;
          localStorage.setItem("payme_walletconnect", JSON.stringify(st));
        } catch(e){}
      });

      provider.on && provider.on("disconnect", (code, reason) => {
        localStorage.removeItem("payme_walletconnect");
        statusEl.textContent = "Disconnected";
        connectBtn.textContent = "Connect Wallet";
      });
    } catch(e){
      console.warn("Event handlers attach failed", e);
    }

    // initial status check
    await refreshStatus();

    // optionally poll status every few seconds to keep UI in sync with external changes
    setInterval(refreshStatus, 5000);

  })();
  </script>
</body>
</html>